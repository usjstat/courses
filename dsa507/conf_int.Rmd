---
title: "Cricket Batting Average: Visualizing Confidence Intervals"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
library(shiny)
library(ggplot2)
```

```{r, echo=FALSE}
fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("n", "Sample Size (innings):", min = 10, max = 100, value = 30),
      sliderInput("conf", "Confidence Level (%):", min = 80, max = 99, value = 95),
      sliderInput("B", "Bootstrap Replicates:", min = 100, max = 5000, value = 1000, step = 100),
      selectInput("type", "Player Type:",
                  choices = c("Consistent", "Aggressive", "Unpredictable")),
      actionButton("go", "Simulate Player")
    ),
    
    mainPanel(
      h4("Sampling Distribution"),
      plotOutput("histPlot"),
      hr(),
      h4("Visual CI Interpretation"),
      plotOutput("ciVisual"),
      verbatimTextOutput("summaryText")
    )
  )
)
```

```{r, echo=FALSE}
# Define population generator
generate_population <- function(type) {
  if (type == "Consistent") {
    runs <- rnorm(10000, mean = 40, sd = 8)
  } else if (type == "Aggressive") {
    runs <- rlnorm(10000, meanlog = log(35), sdlog = 0.5)
  } else {
    runs <- c(rnorm(8000, 20, 10), rnorm(2000, 70, 20))
  }
  round(pmax(runs, 0))
}

# Reactive store
rv <- reactiveValues(
  data = NULL,
  pop = generate_population("Consistent")
)

# On simulate button
observeEvent(input$go, {
  rv$pop <- generate_population(input$type)
  rv$data <- sample(rv$pop, size = input$n)
})

# Histogram plot
output$histPlot <- renderPlot({
  req(rv$data)
  df <- data.frame(Runs = rv$data)
  ggplot(df, aes(Runs)) +
    geom_histogram(bins = 20, fill = "lightblue", color = "black") +
    labs(title = "Histogram of Sampled Innings", x = "Runs", y = "Frequency") +
    theme_minimal()
})

# Visual CI interpretation
output$ciVisual <- renderPlot({
  req(rv$data)
  smp <- rv$data
  pop <- rv$pop
  mean_smp <- mean(smp)
  mean_pop <- mean(pop)
  se <- sd(smp) / sqrt(length(smp))
  alpha <- 1 - input$conf / 100
  z <- qnorm(1 - alpha / 2)

  norm_ci <- c(mean_smp - z * se, mean_smp + z * se)
  boot_means <- replicate(input$B, mean(sample(smp, replace = TRUE)))
  boot_ci <- quantile(boot_means, probs = c(alpha / 2, 1 - alpha / 2))

  plot(NULL, xlim = range(c(norm_ci, boot_ci, mean_pop)) + c(-5, 5), ylim = c(0.5, 2.5),
       xlab = "Batting Average", ylab = "", yaxt = "n",
       main = "Confidence Interval Interpretation")

  abline(v = mean_pop, col = "red", lty = 1, lwd = 2)
  axis(2, at = c(1, 2), labels = c("Normal CI", "Bootstrap CI"), las = 1)

  segments(norm_ci[1], 1, norm_ci[2], 1, col = "darkgreen", lty = 2, lwd = 3)
  text(norm_ci[1], 1.1, paste0("(", round(norm_ci[1], 1)), col = "darkgreen", pos = 4)
  text(norm_ci[2], 1.1, paste0(round(norm_ci[2], 1), ")"), col = "darkgreen", pos = 2)

  segments(boot_ci[1], 2, boot_ci[2], 2, col = "purple", lty = 4, lwd = 3)
  text(boot_ci[1], 2.1, paste0("(", round(boot_ci[1], 1)), col = "purple", pos = 4)
  text(boot_ci[2], 2.1, paste0(round(boot_ci[2], 1), ")"), col = "purple", pos = 2)

  legend("topright", legend = "True Mean", col = "red", lty = 1, lwd = 2)
})

# Summary text
output$summaryText <- renderPrint({
  req(rv$data)
  smp <- rv$data
  pop <- rv$pop
  mean_smp <- mean(smp)
  mean_pop <- mean(pop)
  se <- sd(smp) / sqrt(length(smp))
  alpha <- 1 - input$conf / 100
  z <- qnorm(1 - alpha / 2)

  norm_ci <- c(mean_smp - z * se, mean_smp + z * se)
  boot_means <- replicate(input$B, mean(sample(smp, replace = TRUE)))
  boot_ci <- quantile(boot_means, probs = c(alpha / 2, 1 - alpha / 2))

  cat("Sample Mean:", round(mean_smp, 2), "\n")
  cat("True Population Mean:", round(mean_pop, 2), "\n\n")
  cat("Normal CI:", round(norm_ci[1], 2), "to", round(norm_ci[2], 2), "\n")
  cat("Bootstrap CI:", round(boot_ci[1], 2), "to", round(boot_ci[2], 2), "\n")
  cat("\nDoes each CI contain the true mean?\n")
  cat("Normal CI:", mean_pop >= norm_ci[1] && mean_pop <= norm_ci[2], "\n")
  cat("Bootstrap CI:", mean_pop >= boot_ci[1] && mean_pop <= boot_ci[2], "\n")
})
```
